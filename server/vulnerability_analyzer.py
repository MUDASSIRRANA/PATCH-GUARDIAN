import re
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict
import json
import argparse
import sys
import requests
import time
from typing import Dict, List, Optional, Set, Tuple
import xml.etree.ElementTree as ET
from bs4 import BeautifulSoup

class CWEAPIClient:
    """Client for fetching CWE information from MITRE's CWE API"""
    
    def __init__(self):
        self.base_url = "https://cwe.mitre.org/data/definitions"
        self.cache = {}
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'CWE-Vulnerability-Scanner/1.0'
        })
        # Fallback mitigations for common CWEs
        self.mitigation_fallback = {
            'CWE-78': [
                "Validate and sanitize all user input before using it in OS commands.",
                "Use parameterized APIs or safe libraries instead of system calls.",
                "Avoid constructing OS commands with user input."
            ],
            'CWE-401': [
                "Always release memory after allocation using delete/delete[] or free().",
                "Use smart pointers (e.g., std::unique_ptr, std::shared_ptr) in C++.",
                "Use memory analysis tools to detect leaks."
            ],
            'CWE-22': [
                "Validate and sanitize all user input used in file paths.",
                "Use a whitelist of allowed file names or paths.",
                "Use canonical path resolution and check that resolved path is within restricted directory.",
                "Avoid constructing file paths from user input.",
            ],
            'CWE-134': [
                "Never use user input as a format string.",
                "Use format string constants.",
                "Validate and sanitize all user input."
            ],
            'CWE-120': [
                "Double check that your buffer is as large as you specify.",
                "When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.",
                "Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space."
            ],
            'CWE-121': [
                "Use safe string functions.",
                "Implement stack canaries.",
                "Use ASLR (Address Space Layout Randomization)."
            ],
            'CWE-122': [
                "Use safe heap management.",
                "Implement heap protection mechanisms.",
                "Validate all buffer sizes before use."
            ],
        }
    
    def get_cwe_info(self, cwe_id: str) -> Optional[Dict]:
        """Fetch CWE information from the API"""
        if cwe_id in self.cache:
            return self.cache[cwe_id]
        
        try:
            cwe_number = cwe_id.replace('CWE-', '')
            url = f"{self.base_url}/{cwe_number}.html"
            
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            
            cwe_info = self._parse_cwe_html(response.text, cwe_id)
            self.cache[cwe_id] = cwe_info
            time.sleep(0.1)  # Rate limiting
            
            return cwe_info
            
        except Exception as e:
            print(f"Warning: Could not fetch CWE information for {cwe_id}: {e}", file=sys.stderr)
            return self._get_fallback_cwe_info(cwe_id)
    
    def _parse_cwe_html(self, html_content: str, cwe_id: str) -> Dict:
        """Parse CWE HTML page to extract relevant information using BeautifulSoup"""
        def is_developer_focused(mit):
            generic_keywords = [
                "Architecture and Design",
                "Operation",
                "Strategy",
                "Policy",
                "Process",
                "Organization"
            ]
            return not any(mit.strip().startswith(keyword) for keyword in generic_keywords)

        def is_code_related(mit):
            code_keywords = [
                "input validation", "output encoding", "escaping", "quoting", "sanitize", "allowlist", "whitelist",
                "blacklist", "parameterized", "safe api", "vetted library", "encode", "decode", "validation",
                "replace", "function", "command shell", "structured mechanisms", "separation between data and code",
                "use ", "avoid ", "do not use", "never use", "always use", "functions", "apis", "library", "framework",
                "command injection", "system", "exec", "strcpy", "strcat", "snprintf", "dangerous function", "buffer overflow"
            ]
            mit_lower = mit.lower()
            return any(kw in mit_lower for kw in code_keywords)

        info = {
            'cwe_id': cwe_id,
            'cwe_name': 'Unknown',
            'cwe_description': 'Description not available',
            'cwe_severity': 'Unknown',
            'mitigation': [],
            'references': []
        }
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            # Extract CWE name from <title>
            if soup.title and soup.title.string:
                title_text = soup.title.string
                match = re.search(r'CWE-\d+:\s*(.*)', title_text)
                if match:
                    info['cwe_name'] = match.group(1).strip()
            # Extract description
            desc_div = soup.find('div', id='Description')
            if desc_div:
                indent_div = desc_div.find('div', class_='indent')
                if indent_div:
                    description = indent_div.get_text(separator=' ', strip=True)
                    info['cwe_description'] = description[:500] + ('...' if len(description) > 500 else '')
            # Extract mitigations (robust)
            mit_div = soup.find('div', id='Potential_Mitigations')
            if mit_div:
                indent_div = mit_div.find('div', class_='indent')
                if indent_div:
                    # Try to extract from <li> tags first
                    mitigations = [li.get_text(separator=' ', strip=True) for li in indent_div.find_all('li')]
                    # If no <li>, try <p> tags
                    if not mitigations:
                        mitigations = [p.get_text(separator=' ', strip=True) for p in indent_div.find_all('p')]
                    # If still empty, try direct text
                    if not mitigations:
                        text = indent_div.get_text(separator=' ', strip=True)
                        if text:
                            mitigations = [text]
                    for mitigation in mitigations:
                        info['mitigation'].append(mitigation[:200] + ('...' if len(mitigation) > 200 else ''))
            # Filter to only developer/security-focused mitigations
            filtered_mitigations = [m for m in info['mitigation'] if is_developer_focused(m)]
            # Further filter to only code-related mitigations
            code_mitigations = [m for m in filtered_mitigations if is_code_related(m)]
            # If none left, use fallback
            if not code_mitigations and cwe_id in self.mitigation_fallback:
                code_mitigations = self.mitigation_fallback[cwe_id]
            # After filtering for code-level mitigations:
            code_mitigations = [m for m in info['mitigation'] if is_code_mitigation(m)]

            # Always append your hardcoded best practices if available for this CWE
            if cwe_id in self.mitigation_fallback:
                for fallback_mit in self.mitigation_fallback[cwe_id]:
                    if fallback_mit not in code_mitigations:
                        code_mitigations.append(fallback_mit)

            info['mitigation'] = code_mitigations
            info['references'] = [f"https://cwe.mitre.org/data/definitions/{cwe_id.replace('CWE-', '')}.html"]
            # Determine severity (simple heuristic)
            html_lower = html_content.lower()
            if any(word in html_lower for word in ['critical', 'severe', 'high impact']):
                info['cwe_severity'] = 'Critical'
            elif any(word in html_lower for word in ['high', 'important']):
                info['cwe_severity'] = 'High'
            elif any(word in html_lower for word in ['medium', 'moderate']):
                info['cwe_severity'] = 'Medium'
            else:
                info['cwe_severity'] = 'Low'
        except Exception as e:
            print(f"Warning: Error parsing CWE information for {cwe_id}: {e}", file=sys.stderr)
            # Fallback to hardcoded mitigations if scraping fails
            if cwe_id in self.mitigation_fallback:
                info['mitigation'] = self.mitigation_fallback[cwe_id]
        return info
    
    def _get_fallback_cwe_info(self, cwe_id: str) -> Dict:
        """Fallback CWE information when API is not available"""
        fallback_db = {
            'CWE-120': {
                'cwe_name': 'Buffer Copy without Checking Size of Input',
                'cwe_description': 'The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer.',
                'cwe_severity': 'High',
                'mitigation': ['Use safe string functions like strncpy instead of strcpy', 'Validate input size before copying'],
                'references': ['https://cwe.mitre.org/data/definitions/120.html']
            },
            'CWE-121': {
                'cwe_name': 'Stack-based Buffer Overflow',
                'cwe_description': 'A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack.',
                'cwe_severity': 'Critical',
                'mitigation': ['Use safe string functions', 'Implement stack canaries', 'Use ASLR'],
                'references': ['https://cwe.mitre.org/data/definitions/121.html']
            },
            'CWE-122': {
                'cwe_name': 'Heap-based Buffer Overflow',
                'cwe_description': 'A heap-based buffer overflow condition is a condition where the buffer being overwritten is allocated in the heap portion of memory.',
                'cwe_severity': 'Critical',
                'mitigation': ['Use safe heap management', 'Implement heap protection mechanisms'],
                'references': ['https://cwe.mitre.org/data/definitions/122.html']
            },
            'CWE-401': {
                'cwe_name': 'Missing Release of Memory after Effective Lifetime',
                'cwe_description': 'The program does not release memory after it has been used, causing a memory leak.',
                'cwe_severity': 'Medium',
                'mitigation': ['Always release memory after allocation', 'Use memory management tools', 'Implement RAII in C++'],
                'references': ['https://cwe.mitre.org/data/definitions/401.html']
            },
            'CWE-78': {
                'cwe_name': 'Improper Neutralization of Special Elements used in an OS Command',
                'cwe_description': 'The software constructs all or part of an OS command using externally-influenced input.',
                'cwe_severity': 'Critical',
                'mitigation': ['Avoid using system/exec with user input', 'Use parameterized commands', 'Implement input validation'],
                'references': ['https://cwe.mitre.org/data/definitions/78.html']
            },
            'CWE-89': {
                'cwe_name': 'Improper Neutralization of Special Elements used in an SQL Command',
                'cwe_description': 'The software constructs all or part of an SQL command using externally-influenced input.',
                'cwe_severity': 'Critical',
                'mitigation': ['Use parameterized queries', 'Implement input validation', 'Use ORM frameworks'],
                'references': ['https://cwe.mitre.org/data/definitions/89.html']
            },
            'CWE-134': {
                'cwe_name': 'Use of Externally-Controlled Format String',
                'cwe_description': 'The software uses a function that accepts a format string as an argument from an external source.',
                'cwe_severity': 'High',
                'mitigation': ['Never use user input as a format string', 'Use format string constants'],
                'references': ['https://cwe.mitre.org/data/definitions/134.html']
            },
            'CWE-416': {
                'cwe_name': 'Use After Free',
                'cwe_description': 'The program continues to use a pointer after it has been freed.',
                'cwe_severity': 'Critical',
                'mitigation': ['Set pointers to NULL after freeing', 'Use memory debugging tools', 'Implement defensive programming'],
                'references': ['https://cwe.mitre.org/data/definitions/416.html']
            },
            'CWE-22': {
                'cwe_name': 'Improper Limitation of a Pathname to a Restricted Directory',
                'cwe_description': 'The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location outside of that restricted directory.',
                'cwe_severity': 'High',
                'mitigation': [
                    'Validate and sanitize all user input used in file paths',
                    'Use a whitelist of allowed file names or paths',
                    'Use canonical path resolution and check that resolved path is within restricted directory',
                    'Avoid constructing file paths from user input',
                    'Use path validation libraries or functions'
                ],
                'references': ['https://cwe.mitre.org/data/definitions/22.html']
            },
        }
        
        info = fallback_db.get(cwe_id, {
            'cwe_name': 'Unknown Vulnerability',
            'cwe_description': 'Description not available',
            'cwe_severity': 'Unknown',
            'mitigation': ['Review code for security issues'],
            'references': []
        })
        
        return {
            'cwe_id': cwe_id,
            **info
        }

def is_developer_focused(mit):
    # Add more patterns as needed for your context
    generic_keywords = [
        "Architecture and Design",
        "Operation",
        "Strategy",
        "Policy",
        "Process",
        "Organization"
    ]
    # Exclude if the mitigation is just a generic category
    return not any(mit.strip().startswith(keyword) for keyword in generic_keywords)

def is_code_related(mit):
    code_keywords = [
        "input validation", "output encoding", "escaping", "quoting", "sanitize", "allowlist", "whitelist",
        "blacklist", "parameterized", "safe API", "vetted library", "encode", "decode", "validation",
        "replace", "function", "command shell", "structured mechanisms", "separation between data and code",
        "use", "avoid", "do not use", "never use", "always use", "functions", "APIs", "library", "framework"
    ]
    # Lowercase for matching
    mit_lower = mit.lower()
    # Must mention at least one code-related keyword
    return any(kw in mit_lower for kw in code_keywords)

def is_code_mitigation(mit):
    must_have = [
        "input validation", "output encoding", "escaping", "quoting", "sanitize", "allowlist", "whitelist",
        "parameterized", "encode", "decode", "replace", "function", "safe api", "secure function", "dangerous function",
        "avoid", "never use", "do not use", "use ", "validation", "snprintf", "strncpy", "fgets", "prepared statement"
    ]
    must_not_have = [
        "cwe-", "error message", "log message", "be careful", "avoid inconsistent messaging", "tip off", "other weaknesses",
        "ensure that error messages", "record them in log messages", "organization", "policy", "process", "strategy", "sandbox", "jail",
        "architecture", "design", "operation", "framework", "library", "tool", "esapi", "securitymanager", "chroot", "apparmor", "selinux"
    ]
    mit_lower = mit.lower()
    # Exclude if it mentions any of these
    if any(ex in mit_lower for ex in must_not_have):
        return False
    # Only include if it mentions a direct code action or secure function
    return any(kw in mit_lower for kw in must_have)

class CCPPVulnerabilityAnalyzer:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.node_counter = 0
        self.variables = defaultdict(list)
        self.is_cpp = False
        self.cwe_client = CWEAPIClient()
        
        # Enhanced vulnerability to CWE mapping
        self.vuln_to_cwe = {
            'Memory Leak (C-style)': 'CWE-401',
            'Memory Leak (C++-style)': 'CWE-401',
            'Buffer Overflow (gets)': 'CWE-121',
            'Buffer Overflow (strcpy)': 'CWE-120',
            'Buffer Overflow (strcat)': 'CWE-120',
            'Buffer Overflow (sprintf)': 'CWE-120',
            'Buffer Overflow (scanf)': 'CWE-120',
            'Buffer Overflow (heap)': 'CWE-122',
            'Command Injection': 'CWE-78',
            'SQL Injection': 'CWE-89',
            'Format String': 'CWE-134',
            'Use After Free': 'CWE-416',
            'Path Traversal': 'CWE-22',
        }
        
        # Enhanced patterns for detection
        self.dangerous_functions = {
            'buffer_overflow': {
                'gets': {'severity': 'Critical', 'alternative': 'fgets'},
                'strcpy': {'severity': 'High', 'alternative': 'strncpy'},
                'strcat': {'severity': 'High', 'alternative': 'strncat'},
                'sprintf': {'severity': 'High', 'alternative': 'snprintf'},
                'scanf': {'severity': 'High', 'alternative': 'Use field width specifiers'},
                'vsprintf': {'severity': 'High', 'alternative': 'vsnprintf'},
                'wcscpy': {'severity': 'High', 'alternative': 'wcsncpy'},
                'wcscat': {'severity': 'High', 'alternative': 'wcsncat'},
            },
            'injection': {
                'system': {'severity': 'Critical', 'type': 'command'},
                'exec': {'severity': 'Critical', 'type': 'command'},
                'execl': {'severity': 'Critical', 'type': 'command'},
                'execv': {'severity': 'Critical', 'type': 'command'},
                'popen': {'severity': 'Critical', 'type': 'command'},
                'mysql_query': {'severity': 'Critical', 'type': 'sql'},
                'sqlite3_exec': {'severity': 'Critical', 'type': 'sql'},
            },
            'format_string': {
                'printf': {'severity': 'High'},
                'fprintf': {'severity': 'High'},
                'sprintf': {'severity': 'High'},
                'snprintf': {'severity': 'Medium'},
                'vprintf': {'severity': 'High'},
                'vfprintf': {'severity': 'High'},
                'vsprintf': {'severity': 'High'},
                'vsnprintf': {'severity': 'Medium'},
            },
            'path_traversal': {
                'fopen': {'severity': 'High'},
                'open': {'severity': 'High'},
                'fstream': {'severity': 'High'},
                'ifstream': {'severity': 'High'},
                'ofstream': {'severity': 'High'},
                'freopen': {'severity': 'High'},
                'chdir': {'severity': 'High'},
                'symlink': {'severity': 'High'},
                'readlink': {'severity': 'High'},
                'remove': {'severity': 'High'},
                'unlink': {'severity': 'High'},
                'rename': {'severity': 'High'},
                'mkdir': {'severity': 'High'},
                'rmdir': {'severity': 'High'},
                'CreateFile': {'severity': 'High'},  # Windows
                '_open': {'severity': 'High'},  # Windows
                '_fopen': {'severity': 'High'},  # Windows
                'access': {'severity': 'High'},
                'stat': {'severity': 'High'},
                'lstat': {'severity': 'High'},
            }
        }
        
        # Comprehensive path traversal patterns
        self.path_traversal_patterns = [
            r'\.\./',  # ../
            r'\.\.\\',  # ..\ (Windows)
            r'\.\.',  # .. (general)
            r'/',  # Absolute path (Unix)
            r'\\',  # Windows absolute path
            r'~',  # Home directory
            r'%2e%2e%2f',  # URL-encoded ../
            r'%2e%2e%5c',  # URL-encoded ..\
            r'\.\.%2f',  # Mixed encoding
            r'\.\.%5c',  # Mixed encoding (Windows)
            r'\.\.%c0%af',  # Unicode encoding
            r'\.\.%c1%9c',  # Unicode encoding (Windows)
        ]
        
    def parse_code(self, code):
        """Enhanced code parsing with better statement detection"""
        self.is_cpp = self._detect_cpp(code)
        
        # Normalize and clean code
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)
        
        lines = code.strip().split('\n')
        statements = []
        
        current_statement = ""
        in_class_definition = False
        brace_count = 0
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line or line.startswith('//'):
                continue
                
            # Remove line comments
            line = re.sub(r'//.*$', '', line).strip()
            if not line:
                continue
            
            # Skip preprocessor directives
            if line.startswith('#'):
                continue
                
            # Track class definitions (C++)
            if self.is_cpp and re.search(r'\bclass\s+\w+', line):
                in_class_definition = True
                
            if in_class_definition:
                if '{' in line:
                    brace_count += line.count('{')
                if '}' in line:
                    brace_count -= line.count('}')
                    if brace_count <= 0:
                        in_class_definition = False
                continue
            
            # Collect multi-line statement
            current_statement += " " + line if current_statement else line
            
            # Check if statement is complete
            if (line.endswith(';') or line.endswith('}') or line.endswith('{') or 
                re.search(r'^\s*}', line)):
                
                stmt = {
                    'line_num': i + 1,
                    'code': current_statement.strip(),
                    'type': self._classify_statement(current_statement),
                    'vars_defined': self._extract_defined_vars(current_statement),
                    'vars_used': self._extract_used_vars(current_statement),
                    'function_calls': self._extract_function_calls(current_statement)
                }
                statements.append(stmt)
                current_statement = ""
        
        return statements
    
    def _detect_cpp(self, code):
        """Enhanced C++ detection"""
        cpp_patterns = [
            r'\bclass\b', r'\bnew\b', r'\bdelete\b', r'::', r'\bnamespace\b',
            r'\btemplate\b', r'\bcout\b', r'\bcin\b', r'\bstd::', r'\bvector\b',
            r'\bstring\b(?!\s+\w+\[\])', r'<\s*\w+\s*>', r'\bpublic:', r'\bprivate:',
            r'\bprotected:', r'\bvirtual\b', r'\boverride\b', r'\bauto\b',
            r'#include\s*<iostream>', r'#include\s*<vector>', r'#include\s*<string>'
        ]
        
        for pattern in cpp_patterns:
            if re.search(pattern, code):
                return True
        return False
    
    def _classify_statement(self, line):
        """Enhanced statement classification"""
        if self.is_cpp:
            if re.search(r'\bnew\b', line) and '=' in line:
                return 'cpp_memory_allocation'
            elif re.search(r'\bdelete\b', line):
                return 'cpp_memory_free'
            elif 'std::' in line and any(container in line for container in ['vector', 'string', 'array', 'map', 'set']):
                return 'cpp_container'
            elif 'std::cout' in line or 'std::cin' in line:
                return 'cpp_io'
        
        # Enhanced classification
        if '=' in line and not re.search(r'[!=<>]=', line):
            return 'assignment'
        elif any(func in line for func in ['printf', 'scanf', 'gets', 'system', 'exec']):
            return 'function_call'
        elif re.search(r'\b(malloc|calloc|realloc|strdup|strndup|asprintf|vasprintf)\b', line):
            return 'memory_allocation'
        elif re.search(r'\bfree\b', line):
            return 'memory_free'
        elif re.search(r'^\s*if\b', line) or '?' in line:
            return 'condition'
        elif re.search(r'^\s*(while|for)\b', line):
            return 'loop'
        elif re.search(r'\breturn\b', line):
            return 'return'
        else:
            return 'other'
    
    def _extract_defined_vars(self, line):
        """Enhanced variable definition extraction"""
        defined_vars = []
        
        # C++ new operator
        if self.is_cpp and 'new ' in line and '=' in line:
            left_side = line.split('=')[0].strip()
            var_match = re.search(r'(\w+)(?:\s*\[\w*\])?\s*$', left_side)
            if var_match:
                defined_vars.append(var_match.group(1))
        
        # C++ containers
        if self.is_cpp and 'std::' in line:
            container_match = re.search(r'std::\w+(?:<[^>]*>)?\s+(\w+)', line)
            if container_match:
                defined_vars.append(container_match.group(1))
        
        # Assignment operations
        if '=' in line and not re.search(r'[!=<>]=', line):
            left_side = line.split('=')[0].strip()
            
            # Pointer dereference
            if '*' in left_side:
                ptr_match = re.search(r'\*\s*(\w+)', left_side)
                if ptr_match:
                    defined_vars.append(ptr_match.group(1))
            else:
                # Regular assignment
                var_match = re.search(r'(\w+)(?:\s*\[\w*\])?\s*$', left_side)
                if var_match:
                    defined_vars.append(var_match.group(1))
        
        # Variable declarations
        type_patterns = [
            r'(int|char|float|double|void|unsigned|long|short|bool|size_t)\s*\**\s*(\w+)',
            r'(struct\s+\w+|union\s+\w+)\s*\**\s*(\w+)',
            r'(\w+_t)\s*\**\s*(\w+)'  # Common typedef patterns
        ]
        
        for pattern in type_patterns:
            matches = re.findall(pattern, line)
            for match in matches:
                if len(match) >= 2:
                    defined_vars.append(match[-1])
        
        # Memory allocation (including casts like (char*)malloc)
        if re.search(r'\b(malloc|calloc|realloc|strdup|strndup|asprintf|vasprintf)\b', line) and '=' in line:
            left_side = line.split('=')[0].strip()
            # Handle casts: (char*)malloc -> extract variable after cast
            # Pattern: (type*)var or var or char* var = ...
            # First try to extract variable name from pointer declaration
            ptr_var_match = re.search(r'(\w+)\s*$', left_side)
            if ptr_var_match:
                var_name = ptr_var_match.group(1)
                # Make sure it's not a type name
                if var_name not in ['char', 'int', 'void', 'float', 'double', 'long', 'short', 'unsigned']:
                    defined_vars.append(var_name)
            # Also try pattern: char* var = (char*)malloc
            ptr_decl_match = re.search(r'\*\s*(\w+)\s*=', line)
            if ptr_decl_match:
                defined_vars.append(ptr_decl_match.group(1))
        
        return list(set(defined_vars))  # Remove duplicates
    
    def _extract_used_vars(self, line):
        """Enhanced variable usage extraction"""
        # Remove string literals and character literals
        line_no_strings = re.sub(r'"[^"]*"', '', line)
        line_no_strings = re.sub(r"'[^']*'", "", line_no_strings)
        
        # Find all identifiers
        all_words = re.findall(r'\b[a-zA-Z_]\w*\b', line_no_strings)
        
        # Extended keywords and built-ins
        keywords = {
            'if', 'else', 'while', 'for', 'return', 'sizeof', 'typedef', 'struct', 'union',
            'class', 'new', 'delete', 'namespace', 'template', 'public', 'private', 'protected',
            'const', 'static', 'extern', 'register', 'auto', 'volatile', 'inline', 'virtual',
            'case', 'switch', 'default', 'break', 'continue', 'goto', 'enum', 'using'
        }
        
        types = {
            'int', 'char', 'float', 'double', 'void', 'unsigned', 'long', 'short', 'bool',
            'size_t', 'ssize_t', 'ptrdiff_t', 'wchar_t', 'int8_t', 'int16_t', 'int32_t',
            'int64_t', 'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t', 'vector', 'string',
            'array', 'map', 'set', 'list', 'deque', 'stack', 'queue', 'priority_queue'
        }
        
        functions = {
            'malloc', 'calloc', 'realloc', 'free', 'printf', 'scanf', 'gets', 'system',
            'exec', 'execl', 'execv', 'popen', 'strcpy', 'strcat', 'sprintf', 'snprintf',
            'cout', 'cin', 'push_back', 'emplace_back', 'size', 'length', 'capacity',
            'fgets', 'fputs', 'fopen', 'fclose', 'fprintf', 'fscanf', 'strlen', 'strcmp'
        }
        
        used_vars = []
        defined_vars = self._extract_defined_vars(line)
        
        for word in all_words:
            if (word not in keywords and 
                word not in types and 
                word not in functions and
                word not in defined_vars):
                used_vars.append(word)
        
        return list(dict.fromkeys(used_vars))  # Remove duplicates preserving order
    
    def _extract_function_calls(self, line):
        """Enhanced function call extraction"""
        # Remove string literals to avoid false positives
        line_no_strings = re.sub(r'"[^"]*"', '', line)
        line_no_strings = re.sub(r"'[^']*'", "", line_no_strings)
        
        # Find function calls including member functions
        function_calls = re.findall(r'(\w+(?:\.\w+|\->\w+)?)\s*\(', line_no_strings)
        
        # Clean up member function calls
        cleaned_calls = []
        for call in function_calls:
            if '.' in call or '->' in call:
                # Extract the function name part
                func_name = call.split('.')[-1].split('->')[-1]
                cleaned_calls.append(func_name)
            else:
                cleaned_calls.append(call)
        
        return cleaned_calls
    
    def build_pdg(self, statements):
        """Build Program Dependence Graph with enhanced tracking"""
        nodes = []
        
        # Create nodes for each statement
        for stmt in statements:
            node_id = self.node_counter
            self.node_counter += 1
            self.graph.add_node(node_id, **stmt)
            nodes.append(node_id)
            
            # Track variable definitions
            for var in stmt['vars_defined']:
                self.variables[var].append(node_id)
        
        # Control flow edges
        for i in range(len(nodes) - 1):
            self.graph.add_edge(nodes[i], nodes[i + 1], type='control_flow')
        
        # Data dependency edges
        for i, stmt in enumerate(statements):
            current_node = nodes[i]
            for used_var in stmt['vars_used']:
                if used_var in self.variables:
                    # Find the most recent definition
                    recent_defs = [def_node for def_node in self.variables[used_var] 
                                 if def_node < current_node]
                    if recent_defs:
                        most_recent = max(recent_defs)
                        self.graph.add_edge(most_recent, current_node, 
                                          type='data_dependency', var=used_var)
        
        # Control dependencies
        control_stack = []
        for i, stmt in enumerate(statements):
            node_id = nodes[i]
            stmt_type = stmt['type']
            
            if stmt_type in {'condition', 'loop'}:
                control_stack.append(node_id)
            
            if stmt_type in {'assignment', 'function_call', 'memory_allocation', 
                           'memory_free', 'cpp_memory_allocation', 'cpp_memory_free'}:
                if control_stack:
                    parent_node = control_stack[-1]
                    self.graph.add_edge(parent_node, node_id, type='control_dependency')
            
            # Handle end of control blocks
            if '}' in stmt['code'] and control_stack:
                control_stack.pop()
    
    def enhance_vulnerability(self, vuln):
        """Enhanced vulnerability enhancement with CWE information"""
        vuln_type = vuln['type']
        cwe_id = self.vuln_to_cwe.get(vuln_type)
        
        if cwe_id:
            print(f"Fetching CWE information for {cwe_id}...", file=sys.stderr)
            cwe_info = self.cwe_client.get_cwe_info(cwe_id)
            if cwe_info:
                # Filter for code-related mitigations
                code_mitigations = [m for m in cwe_info['mitigation'] if is_code_mitigation(m)]
                if not code_mitigations and cwe_id in self.cwe_client.mitigation_fallback:
                    code_mitigations = self.cwe_client.mitigation_fallback[cwe_id]
                cwe_info['mitigation'] = code_mitigations
                vuln.update(cwe_info)
        
        return vuln
    
    def _analyze_memory_leaks(self) -> List[Dict]:
        """Comprehensive memory leak analysis - covers all types of memory leaks"""
        vulnerabilities = []
        
        # C-style memory tracking
        c_allocated = {}  # var_name -> (node_id, allocation_type, code)
        c_freed = set()
        c_reassigned = set()  # Track pointer reassignments
        
        # C++ style memory tracking
        cpp_allocated = {}  # var_name -> (node_id, allocation_type, code)
        cpp_freed = set()
        cpp_reassigned = set()
        
        # Track all allocation functions
        c_alloc_functions = ['malloc', 'calloc', 'realloc', 'strdup', 'strndup', 'asprintf', 'vasprintf']
        cpp_alloc_functions = ['new', 'new[]']
        
        # Track variable scope and lifetime
        for node in self.graph.nodes():
            stmt = self.graph.nodes[node]
            code = stmt['code']
            
            # C-style allocations
            if stmt['type'] == 'memory_allocation':
                for var in stmt['vars_defined']:
                    alloc_type = 'malloc'
                    if 'calloc' in code:
                        alloc_type = 'calloc'
                    elif 'realloc' in code:
                        alloc_type = 'realloc'
                    elif 'strdup' in code or 'strndup' in code:
                        alloc_type = 'strdup' if 'strdup' in code else 'strndup'
                    elif 'asprintf' in code or 'vasprintf' in code:
                        alloc_type = 'asprintf' if 'asprintf' in code else 'vasprintf'
                    c_allocated[var] = (node, alloc_type, code)
            
            # C-style deallocations
            elif stmt['type'] == 'memory_free':
                for var in stmt['vars_used']:
                    c_freed.add(var)
                    if var in c_allocated:
                        del c_allocated[var]  # Remove from tracking
            
            # C++ style allocations
            elif stmt['type'] == 'cpp_memory_allocation':
                for var in stmt['vars_defined']:
                    alloc_type = 'new'
                    if 'new[]' in code:
                        alloc_type = 'new[]'
                    cpp_allocated[var] = (node, alloc_type, code)
            
            # C++ style deallocations
            elif stmt['type'] == 'cpp_memory_free':
                for var in stmt['vars_used']:
                    cpp_freed.add(var)
                    if var in cpp_allocated:
                        del cpp_allocated[var]  # Remove from tracking
            
            # Check for pointer reassignment (losing reference)
            # Pattern: ptr = something (where ptr was allocated)
            if stmt['type'] == 'assignment' and '=' in code:
                for var in stmt['vars_defined']:
                    # Check if this variable was previously allocated
                    if var in c_allocated:
                        # Check if it's being reassigned (not just modified)
                        # Simple heuristic: if right side doesn't contain the var, it's reassignment
                        right_side = code.split('=')[1] if '=' in code else ''
                        if var not in right_side and not any(func in right_side for func in ['malloc', 'calloc', 'realloc']):
                            c_reassigned.add(var)
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Memory Leak (C-style)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'variable': var,
                                'allocation_type': c_allocated[var][1],
                                'severity': 'Medium',
                                'description': f"Variable '{var}' allocated with {c_allocated[var][1]} but pointer is reassigned before being freed, causing memory leak"
                            }))
                    if var in cpp_allocated:
                        right_side = code.split('=')[1] if '=' in code else ''
                        if var not in right_side and 'new' not in right_side:
                            cpp_reassigned.add(var)
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Memory Leak (C++-style)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'variable': var,
                                'allocation_type': cpp_allocated[var][1],
                                'severity': 'Medium',
                                'description': f"Variable '{var}' allocated with {cpp_allocated[var][1]} but pointer is reassigned before being freed, causing memory leak"
                            }))
            
            # Check for early returns without freeing (basic check)
            if stmt['type'] == 'return' and 'return' in code:
                # Check if there are unfreed allocations before this return
                # This is a simplified check - full analysis would need control flow
                pass  # Could be enhanced with control flow analysis
        
        # Check for unfreed C allocations
        for var, (node, alloc_type, alloc_code) in c_allocated.items():
            if var not in c_freed and var not in c_reassigned:
                vulnerabilities.append(self.enhance_vulnerability({
                    'type': 'Memory Leak (C-style)',
                    'node': node,
                    'line': self.graph.nodes[node]['line_num'],
                    'code': self.graph.nodes[node]['code'],
                    'variable': var,
                    'allocation_type': alloc_type,
                    'severity': 'Medium',
                    'description': f"Variable '{var}' allocated with {alloc_type} but never freed with free()"
                }))
        
        # Check for unfreed C++ allocations
        for var, (node, alloc_type, alloc_code) in cpp_allocated.items():
            if var not in cpp_freed and var not in cpp_reassigned:
                delete_type = 'delete[]' if alloc_type == 'new[]' else 'delete'
                vulnerabilities.append(self.enhance_vulnerability({
                    'type': 'Memory Leak (C++-style)',
                    'node': node,
                    'line': self.graph.nodes[node]['line_num'],
                    'code': self.graph.nodes[node]['code'],
                    'variable': var,
                    'allocation_type': alloc_type,
                    'severity': 'Medium',
                    'description': f"Variable '{var}' allocated with '{alloc_type}' but never freed with '{delete_type}'"
                }))
        
        return vulnerabilities
    
    def _analyze_buffer_overflows(self) -> List[Dict]:
        """Comprehensive buffer overflow analysis"""
        vulnerabilities = []
        
        for node in self.graph.nodes():
            stmt = self.graph.nodes[node]
            code = stmt['code']
            function_calls = stmt['function_calls']
            
            # Check for C++ stream input operations (std::cin >> buf)
            # This is a common buffer overflow source in C++
            if self.is_cpp:
                # Pattern: std::cin >> variable or cin >> variable
                cin_pattern = r'(?:std::)?cin\s*>>\s*(\w+)'
                cin_match = re.search(cin_pattern, code)
                if cin_match:
                    var_name = cin_match.group(1)
                    # Check if variable is a fixed-size buffer (char array)
                    # Look for variable definition in previous statements
                    var_is_buffer = False
                    for prev_node in self.graph.nodes():
                        prev_stmt = self.graph.nodes[prev_node]
                        if prev_node < node:  # Only check previous statements
                            # Check if variable is defined as char array
                            if re.search(rf'\bchar\s+{var_name}\s*\[', prev_stmt['code']):
                                var_is_buffer = True
                                break
                    
                    if var_is_buffer:
                        vulnerabilities.append(self.enhance_vulnerability({
                            'type': 'Buffer Overflow (gets)',
                            'node': node,
                            'line': stmt['line_num'],
                            'code': code,
                            'severity': 'Critical',
                            'function': 'std::cin >>',
                            'description': f"Using 'std::cin >> {var_name}' on a fixed-size buffer can cause buffer overflow. Use 'std::cin.getline()' or 'std::cin.read()' with buffer size limits instead."
                        }))
            
            # Check each dangerous function
            for func_name in function_calls:
                if func_name in self.dangerous_functions['buffer_overflow']:
                    func_info = self.dangerous_functions['buffer_overflow'][func_name]
                    
                    # Specific checks for different functions
                    if func_name == 'gets':
                        vulnerabilities.append(self.enhance_vulnerability({
                            'type': 'Buffer Overflow (gets)',
                            'node': node,
                            'line': stmt['line_num'],
                            'code': code,
                            'severity': func_info['severity'],
                            'function': func_name,
                            'description': f"Function '{func_name}' is inherently unsafe and can cause buffer overflow. Use '{func_info['alternative']}' instead."
                        }))
                    
                    elif func_name == 'strcpy':
                        if 'strncpy' not in code:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (strcpy)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': f"Function '{func_name}' used without bounds checking. Use '{func_info['alternative']}' instead."
                            }))
                    elif func_name == 'strcat':
                        if 'strncat' not in code:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (strcat)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': f"Function '{func_name}' used without bounds checking. Use '{func_info['alternative']}' instead."
                            }))
                    elif func_name == 'sprintf':
                        if 'snprintf' not in code:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (sprintf)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': f"Function '{func_name}' used without bounds checking. Use '{func_info['alternative']}' instead."
                            }))
                    elif func_name == 'scanf':
                        if not re.search(r'%\d*[s]', code):
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (scanf)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': "'scanf' used without field width specifier for %s. This can cause buffer overflow. Use field width specifiers."
                            }))
                    elif func_name == 'vsprintf':
                        if 'vsnprintf' not in code:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (sprintf)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': "'vsprintf' used without bounds checking. Use 'vsnprintf' instead."
                            }))
                    elif func_name == 'wcscpy':
                        if 'wcsncpy' not in code:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (strcpy)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': "'wcscpy' used without bounds checking. Use 'wcsncpy' instead."
                            }))
                    elif func_name == 'wcscat':
                        if 'wcsncat' not in code:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Buffer Overflow (strcat)',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': func_info['severity'],
                                'function': func_name,
                                'description': "'wcscat' used without bounds checking. Use 'wcsncat' instead."
                            }))
        return vulnerabilities

    def _analyze_command_injections(self) -> List[Dict]:
        """Detect potential command injection vulnerabilities"""
        vulnerabilities = []

        for node in self.graph.nodes():
            stmt = self.graph.nodes[node]
            code = stmt['code']
            function_calls = stmt['function_calls']

            for func_name in function_calls:
                if func_name in self.dangerous_functions['injection']:
                    inj_info = self.dangerous_functions['injection'][func_name]
                    if inj_info['type'] == 'command':
                        vulnerabilities.append(self.enhance_vulnerability({
                            'type': 'Command Injection',
                            'node': node,
                            'line': stmt['line_num'],
                            'code': code,
                            'severity': inj_info['severity'],
                            'function': func_name,
                            'description': f"Command injection risk via '{func_name}'. Avoid passing unsanitized user input to this function."
                        }))

        return vulnerabilities

    def _analyze_path_traversal(self) -> List[Dict]:
        """Comprehensive path traversal detection - covers all types of path traversal vulnerabilities"""
        vulnerabilities = []
        seen_vulns = set()  # Avoid duplicates

        for node in self.graph.nodes():
            stmt = self.graph.nodes[node]
            code = stmt['code']
            function_calls = stmt['function_calls']

            # Check for file operations that might use user input
            for func_name in function_calls:
                if func_name in self.dangerous_functions.get('path_traversal', {}):
                    # Check if user input (variables) is used in the file path
                    used_vars = stmt['vars_used']
                    
                    # Create unique identifier for this vulnerability
                    vuln_id = f"{node}_{func_name}"
                    
                    # Look for path traversal patterns in the code (including URL-encoded)
                    pattern_found = False
                    for pattern in self.path_traversal_patterns:
                        if re.search(pattern, code, re.IGNORECASE):
                            pattern_found = True
                            break
                    
                    # Check if variables are used without validation
                    has_validation = any(keyword in code.lower() for keyword in [
                        'validate', 'sanitize', 'canonical', 'realpath', 'basename',
                        'path_is_safe', 'is_safe_path', 'whitelist', 'allowlist',
                        'strstr.*\.\.', 'contains.*\.\.'  # Basic checks for .. detection
                    ])
                    
                    # Check if the function call uses variables (potential user input)
                    var_in_path = False
                    for var in used_vars:
                        # Check if variable appears in the file path argument
                        # Pattern: func_name(..., var, ...) or func_name(var, ...)
                        func_pattern = rf'{func_name}\s*\([^)]*\b{var}\b'
                        if re.search(func_pattern, code):
                            var_in_path = True
                            break
                    
                    # Also check for C++ string concatenation patterns with ifstream/ofstream
                    # Pattern: ifstream f("string" + var) or ifstream f(var)
                    if self.is_cpp and not var_in_path:
                        for var in used_vars:
                            # Check for string concatenation: "files/" + path
                            concat_patterns = [
                                rf'["\'][^"\']*["\']\s*\+\s*\b{var}\b',  # "string" + var
                                rf'\b{var}\b\s*\+\s*["\'][^"\']*["\']',  # var + "string"
                                rf'std::string.*\+\s*\b{var}\b',  # std::string + var
                                rf'\b{var}\b\s*\+\s*std::string',  # var + std::string
                            ]
                            for pattern in concat_patterns:
                                if re.search(pattern, code):
                                    var_in_path = True
                                    break
                            
                            # Check for ifstream/ofstream constructor with string
                            # Pattern: ifstream f("path" + var) or ifstream f(var) or std::ifstream f(...)
                            stream_patterns = [
                                rf'(?:std::)?(?:i|o)?fstream\s+\w+\s*\([^)]*\b{var}\b',  # ifstream f(var)
                                rf'(?:std::)?(?:i|o)?fstream\s+\w+\s*\([^)]*\+\s*\b{var}\b',  # ifstream f("path" + var)
                                rf'(?:std::)?(?:i|o)?fstream\s+\w+\s*\([^)]*\b{var}\b\s*\+',  # ifstream f(var + "path")
                            ]
                            for pattern in stream_patterns:
                                if re.search(pattern, code):
                                    var_in_path = True
                                    break
                            
                            if var_in_path:
                                break
                    
                    # Report vulnerability if:
                    # 1. Path traversal patterns found, OR
                    # 2. User input used without validation
                    if (pattern_found or var_in_path) and not has_validation:
                        if vuln_id not in seen_vulns:
                            seen_vulns.add(vuln_id)
                            
                            # Determine specific issue
                            if pattern_found:
                                desc = f"Path traversal pattern detected in '{func_name}' call. User input contains '../', '..\\', or other path traversal sequences. Validate and sanitize file paths."
                            elif var_in_path:
                                desc = f"Potential path traversal vulnerability via '{func_name}' with user input. File path may not be validated, allowing access to files outside intended directory."
                            else:
                                desc = f"Potential path traversal vulnerability via '{func_name}'. Validate and sanitize file paths."
                            
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Path Traversal',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': 'High',
                                'function': func_name,
                                'description': desc
                            }))
                    
                    # Special check for chdir() - changing directory with user input
                    if func_name == 'chdir' and var_in_path and not has_validation:
                        if f"{vuln_id}_chdir" not in seen_vulns:
                            seen_vulns.add(f"{vuln_id}_chdir")
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Path Traversal',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': 'High',
                                'function': func_name,
                                'description': f"Directory change via '{func_name}' with user input. This can allow escaping to parent directories. Validate and restrict directory paths."
                            }))
                    
                    # Special check for symlink() - creating symlinks with user input
                    if func_name == 'symlink' and var_in_path and not has_validation:
                        if f"{vuln_id}_symlink" not in seen_vulns:
                            seen_vulns.add(f"{vuln_id}_symlink")
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Path Traversal',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': 'High',
                                'function': func_name,
                                'description': f"Symlink creation via '{func_name}' with user input. This can allow creating symlinks to arbitrary locations. Validate and restrict paths."
                            }))

        return vulnerabilities

    def _analyze_sql_injection(self) -> List[Dict]:
        """Detect SQL injection vulnerabilities via string concatenation"""
        vulnerabilities = []
        
        for node in self.graph.nodes():
            stmt = self.graph.nodes[node]
            code = stmt['code']
            
            # Check for SQL query patterns with string concatenation
            sql_patterns = [
                r'SELECT\s+.*?\s+FROM\s+.*?[\'"\s]+\+',  # SELECT ... FROM ... ' + var
                r'[\'"\s]+\+\s*.*?\s+SELECT',  # var + ' SELECT
                r'INSERT\s+INTO\s+.*?[\'"\s]+\+',  # INSERT INTO ... ' + var
                r'UPDATE\s+.*?SET\s+.*?[\'"\s]+\+',  # UPDATE ... SET ... ' + var
                r'DELETE\s+FROM\s+.*?[\'"\s]+\+',  # DELETE FROM ... ' + var
                r'WHERE\s+.*?[\'"\s]+\+',  # WHERE ... ' + var
            ]
            
            # Check for SQL string concatenation patterns
            for pattern in sql_patterns:
                if re.search(pattern, code, re.IGNORECASE):
                    # Check if user input (variables) is used
                    used_vars = stmt['vars_used']
                    if used_vars:
                        vulnerabilities.append(self.enhance_vulnerability({
                            'type': 'SQL Injection',
                            'node': node,
                            'line': stmt['line_num'],
                            'code': code,
                            'severity': 'Critical',
                            'description': f"SQL injection risk via string concatenation. User input '{', '.join(used_vars)}' is directly concatenated into SQL query without parameterization. Use prepared statements or parameterized queries."
                        }))
                        break
            
            # Also check for explicit SQL query construction with variables
            # Pattern: "SELECT * FROM users WHERE name = '" + user + "'"
            if re.search(r'SELECT|INSERT|UPDATE|DELETE', code, re.IGNORECASE):
                # Check for string concatenation with variables
                if '+' in code and stmt['vars_used']:
                    # Check if it looks like SQL query construction
                    if any(keyword in code.upper() for keyword in ['WHERE', 'FROM', 'SET', 'VALUES']):
                        vulnerabilities.append(self.enhance_vulnerability({
                            'type': 'SQL Injection',
                            'node': node,
                            'line': stmt['line_num'],
                            'code': code,
                            'severity': 'Critical',
                            'description': f"SQL injection risk via string concatenation. User input is directly concatenated into SQL query without parameterization. Use prepared statements or parameterized queries."
                        }))
        
        return vulnerabilities
    
    def _analyze_command_injection_enhanced(self) -> List[Dict]:
        """Enhanced command injection detection - also detects sprintf building commands"""
        vulnerabilities = []
        command_builders = {}  # Track variables that build commands
        
        for node in self.graph.nodes():
            stmt = self.graph.nodes[node]
            code = stmt['code']
            function_calls = stmt['function_calls']
            
            # Track sprintf/snprintf building commands
            if 'sprintf' in function_calls or 'snprintf' in function_calls:
                # Extract the command variable name
                # Pattern: sprintf(cmd, "format", ...)
                sprintf_match = re.search(r'(?:s|sn)printf\s*\(\s*(\w+)', code)
                if sprintf_match:
                    cmd_var = sprintf_match.group(1)
                    # Check if format string contains user input patterns
                    if stmt['vars_used']:
                        command_builders[cmd_var] = (node, stmt['line_num'], code, stmt['vars_used'])
            
            # Check if a command builder variable is used in system/exec
            for func_name in function_calls:
                if func_name in ['system', 'exec', 'execl', 'execv', 'popen']:
                    # Check if any command builder variable is used
                    for cmd_var, (builder_node, builder_line, builder_code, builder_vars) in command_builders.items():
                        if cmd_var in stmt['vars_used']:
                            vulnerabilities.append(self.enhance_vulnerability({
                                'type': 'Command Injection',
                                'node': node,
                                'line': stmt['line_num'],
                                'code': code,
                                'severity': 'Critical',
                                'function': func_name,
                                'description': f"Command injection risk: Command built with sprintf at line {builder_line} using user input '{', '.join(builder_vars)}' is passed to '{func_name}'. Avoid constructing commands with user input."
                            }))
        
        return vulnerabilities

    def analyze(self, code: str) -> List[Dict]:
        statements = self.parse_code(code)
        self.build_pdg(statements)

        vulnerabilities = []
        vulnerabilities.extend(self._analyze_memory_leaks())
        vulnerabilities.extend(self._analyze_buffer_overflows())
        vulnerabilities.extend(self._analyze_command_injections())
        vulnerabilities.extend(self._analyze_command_injection_enhanced())  # Enhanced detection
        vulnerabilities.extend(self._analyze_path_traversal())
        vulnerabilities.extend(self._analyze_sql_injection())  # New SQL injection detection

        return vulnerabilities

if __name__ == "__main__":
    import argparse
    import sys
    import json

    parser = argparse.ArgumentParser(description='Analyze C/C++ code for vulnerabilities')
    parser.add_argument('file', nargs='?', help='Path to the C/C++ file to analyze')
    args = parser.parse_args()

    def read_file(file_path):
        encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
        for encoding in encodings:
            try:
                with open(file_path, 'r', encoding=encoding) as f:
                    return f.read()
            except UnicodeDecodeError:
                continue
        try:
            with open(file_path, 'rb') as f:
                return f.read().decode('latin-1')
        except Exception as e:
            print(f"Error reading file {file_path}: {e}", file=sys.stderr)
            return None

    analyzer = CCPPVulnerabilityAnalyzer()
    if args.file:
        code = read_file(args.file)
        if not code:
            print(json.dumps({'error': 'Could not read file'}))
            sys.exit(1)
        vulnerabilities = analyzer.analyze(code)
        print(json.dumps({'vulnerabilities': vulnerabilities}, indent=2))
    else:
        # Read code from stdin
        code = sys.stdin.read()
        vulnerabilities = analyzer.analyze(code)
        print(json.dumps({'vulnerabilities': vulnerabilities}, indent=2))